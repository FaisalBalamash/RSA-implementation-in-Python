# -*- coding: utf-8 -*-
"""CPIT425_Project

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14ALxJCdJG49NO2By9nBRFhkL9LdVZhgI
"""

import random
from typing import Tuple
import math

def isPrime(n):
  if n <= 1:
    return False
  elif n <= 3:
    return True
  elif n % 2 == 0 or n % 3 == 0:
    return False
  i = 5
  while i * i <= n:
    if n % i == 0 or n % (i + 2) == 0:
      return False
    i += 6
  return True

def generate_prime_between(low: int, high: int) -> int:
    """Return a prime number between low and high (inclusive)."""
    while True:
        num = random.randint(low, high)
        if isPrime(num):
            return num

def modular_inverse(a: int, m: int) -> int:
    """Return the modular inverse of a modulo m, if it exists.

    Preconditions:
        - a and m are positive integers
        - a and m are coprime
    """
    t, new_t = 0, 1
    r, new_r = m, a

    while new_r != 0:
        quotient = r // new_r
        t, new_t = new_t, t - quotient * new_t
        r, new_r = new_r, r - quotient * new_r

    if r > 1:
        raise ValueError("a is not invertible modulo m")
    if t < 0:
        t += m

    return t

def rsa_generate_key(p: int, q: int) -> \
    Tuple[Tuple[int, int, int], Tuple[int, int]]:
    """Return an RSA key pair generated using primes p and q.

    The return value is a tuple containing two tuples:
      1. The first tuple is the private key, containing (p, q, d).
      2. The second tuple is the public key, containing (n, e).

    Preconditions:
        - p and q are prime
        - p != q
    """
    # Compute the product of p and q
    n = p * q

    # Choose e such that gcd(e, phi_n) == 1.
    phi_n = (p - 1) * (q - 1)

    # Since e is chosen randomly, we repeat the random choice
    # until e is coprime to phi_n.
    e = random.randint(2, phi_n - 1)
    while math.gcd(e, phi_n) != 1:
        e = random.randint(2, phi_n - 1)

    # Choose d such that e * d % phi_n = 1.
    # Notice that we're using our modular_inverse from our work in the last chapter!
    d = modular_inverse(e, phi_n)

    return ((p, q, d), (n, e))

def rsa_encrypt(public_key: Tuple[int, int], plaintext: int) -> int:
    """Encrypt the given plaintext using the recipient's public key.

    Preconditions:
        - public_key is a valid RSA public key (n, e)
        - 0 < plaintext < public_key[0]
    """
    n, e = public_key

    encrypted = (plaintext ** e) % n

    return encrypted

def rsa_decrypt(private_key: Tuple[int, int, int],  ciphertext: int) -> int:
    """Decrypt the given ciphertext using the recipient's private key.

    Preconditions:
        - private_key is a valid RSA private key (p, q, d)
        - 0 < ciphertext < private_key[0] * private_key[1]
    """
    p, q, d = private_key
    n = p * q

    decrypted = (ciphertext ** d) % n

    return decrypted

def encrypt():
  PU_key_path = input("Enter the path to the public key file: ")
  file_to_encrypt = input("Enter the file you wish to encrypt: ")
  encrypted_file = input("Name your encrypted file: ")

  with open(PU_key_path, "r") as f:
    n, e = map(int, f.read().split(","))

  with open(file_to_encrypt, "r") as f:
    file_contents = f.read()
  decimal_string = ''.join([str(ord(c)).zfill(4) for c in file_contents])


  encrypted_numbers = []
  i = 0
  while i < len(decimal_string):
    block = decimal_string[i:i+4]
    # call the rsa encrypt method
    encrypted_numbers.append(str(rsa_encrypt((n, e),int(block))).zfill(8))
    i += 4

  with open(encrypted_file, "w") as f:
    f.write(' '.join(encrypted_numbers))

def decrypt():
  PV_key_path = input("Enter the path the the private key file: ")
  file_to_decrypt = input("Enter the path to the file to decrypt: ")
  decrypted_file = input("Name your decrypted file: ")

  with open(PV_key_path, "r") as f:
    p, q, d = map(int, f.read().split(","))

  with open(file_to_decrypt) as f:
    encrypted_numbers = f.read().split()

  decrypted_string = ""
  for number in encrypted_numbers:
    #call the rsa decrypt method
    decrypted_block = str(rsa_decrypt((p, q, d), int(number))).zfill(4)
    for i in range(0, len(decrypted_block), 4):
      decrypted_string += chr(int(decrypted_block[i:i+4]))

  with open(decrypted_file, "w") as f:
    f.write(decrypted_string)

def generate_keys():
  p = generate_prime_between(100, 200)
  q = generate_prime_between(100, 200)

  private_key, public_key = rsa_generate_key(p, q)

  with open("public_key.txt", "w") as f:
    f.write(f"{public_key[0]}, {public_key[1]}")
  with open("private_key.txt", "w") as f:
    f.write(f"{private_key[0]}, {private_key[1]}, {private_key[2]}")

"""Choice 1 will create a file of the keys in the "Files" tab of google collab

Choice 2 will prompt you to enter the path to the public key and the file you wish to encrypt and the name of the file you want to create

Choice 3 will prompt you to enter the path to the private key and the file you wish to decrypt and the name of the file you want to create

Choice 4 will terminate the program

In order to get the file path click on the file icon, navigate to the file name, right click, and click on "copy path". insert the path in the terminal to continue the program.
"""

while True:
    print("\nWelcome to our security services system, Please select a choice")
    print("1. Generate a key")
    print("2. Encrypt file")
    print("3. Decrypt a file")
    print("4. Terminate\n")
    choice = int(input("Enter your choice: (must be a number from 1 to 4)\n"))
    if choice == 1:
      generate_keys()
      print("\nKeys are generated successfully , navigate the files to see your keys\n")
    elif choice == 2:
      encrypt()
    elif choice == 3:
      decrypt()
    elif choice == 4:
      break
    else:
      print("\nWrong input, please select one of the correct options 1-4\n")